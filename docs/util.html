<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>progbg.util API documentation</title>
<meta name="description" content="Utility function and classes used throughout progbg" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>progbg.util</code></h1>
</header>
<section id="section-intro">
<p>Utility function and classes used throughout progbg</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Utility function and classes used throughout progbg&#34;&#34;&#34;
import itertools
import sys
import os
from pprint import pformat
from typing import List, Dict, Tuple


import numpy as np
import pandas as pd

from .globals import _sb_rnames

REQUIRED = object()


class Metrics:
    &#34;&#34;&#34;Metrics collection object

    This object is given to executions to allow for users to specify what data
    must be kept. The main functio that should be used by users is the add_metric
    function, which simply appends data points to a list to be used to calculate
    means and standard deviation later
    &#34;&#34;&#34;

    def __init__(self):
        self._vars = dict()
        self._consts = dict()

    def add_metric(self, key, val):
        &#34;&#34;&#34;Add a data point to a metric key

        Args:
            key (str): Key to add value to
            val (int, float): value to append to a list

        Example:
            Suppose we have a parser we wish to use. This parser takes
            both a metrics object and a file path.

            &gt;&gt;&gt; def my_parser(metrics: Metrics, out: str):
            &gt;&gt;&gt;     with open(out, &#39;r&#39;) as f:
            &gt;&gt;&gt;         mydata = f.read()
            &gt;&gt;&gt;         val = find_specific_value(mydata)
            &gt;&gt;&gt;         metrics.add_metric(&#39;my-stored-val&#39;, val)
        &#34;&#34;&#34;
        if key not in self._vars:
            self._vars[key] = [val]
        else:
            self._vars[key].append(val)

    def to_file(self, path):
        stats = self.get_stats()
        with open(path, &#34;w&#34;) as f:
            for k, val in stats.items():
                f.write(&#34;{}={}\n&#34;.format(k, val))

    def add_metrics(self, key, vals):
        for v in vals:
            self.add_metric(key, v)

    def stat(self, key):
        obj = self.get_stats()
        return obj[key]

    def __getitem__(self, key):
        obj = self.get_stats()
        if key in self._vars:
            return self._vars[key]

        return self._consts[key]

    def __contains__(self, key):
        return (key in self._vars) or (key in self._consts)

    def add_constant(self, key, val):
        &#34;&#34;&#34;Add a constant to a metric object

        Args:
            key (str): Key for constant
            val (obj): Value of this constant
        &#34;&#34;&#34;
        self._consts[key] = val

    def _combine(self, other: Dict):
        for key, val in other._vars.items():
            if key in self._vars:
                self._vars[key].append(val)
            else:
                self._vars[key] = val

    def get_stats(self):
        &#34;&#34;&#34;Returns the metrics object

        Will return the current metrics of this object. Each associated
        key will have its mean and standard deviation calculated.  Standard deviation
        is stored within a &#34;_std&#34; key.

        For example. If I had some metrics with associated key &#34;my-metric&#34;. The returned
        dictionary would store the mean at key &#34;my-metrics&#34;, and store standard deviation
        at key &#34;my-metrics_std&#34;.  This allows users to also manually set standard deviation
        of objects if needed. For example when using then `plan_parse` style executions.

        Returns:
            dict
        &#34;&#34;&#34;
        obj = dict()
        for key, val in self._vars.items():
            obj[key] = np.mean(val)
            obj[key + &#34;_std&#34;] = np.std(val)
        for key, val in self._consts.items():
            obj[key] = val

        return obj

    def __repr__(self):
        obj = self.get_stats()
        return pformat(obj)


def normalize(group_list, index_to):
    normal = group_list[index_to]
    final_list = []
    for group in group_list:
        stddev = group[1] / group[0]
        newval = group[0] / normal[0]
        final_list.append((newval, stddev * newval))
    return final_list


def silence_print():
    sys.stdout = open(os.devnull, &#34;w&#34;)


def restore_print():
    sys.stdout.close()
    sys.stdout = sys.__stdout__


def error(strn: str):
    print(&#34;\033[0;31m[Error]:\033[0m {}&#34;.format(strn))
    sys.exit(-1)


def dump_obj(file: str, obj: Dict):
    &#34;&#34;&#34;Dump dictionary to file key=val&#34;&#34;&#34;
    with open(file, &#34;w&#34;) as ofile:
        for key, val in obj.items():
            line = &#34;{}={}\n&#34;.format(key, val)
            ofile.write(line)


def retrieve_obj(file: str) -&gt; Dict:
    &#34;&#34;&#34;Retrieve dictionary from file key=val&#34;&#34;&#34;
    obj = {}
    with open(file, &#34;r&#34;) as ofile:
        for line in ofile.readlines():
            vals = line.strip().split(&#34;=&#34;)
            try:
                obj[vals[0]] = vals[1]
            except:
                print(&#34;Issue with file: {}&#34;.format(file))
                exit(0)
    return obj


class Variables:
    &#34;&#34;&#34;
    Variables is a container class for variables for a given execution

    This will define the permutations that can occur for those that utilize the
    class (see Variables.produce_args documentation)

    Attributes:
        const: A dictionary of argument names to values that will be passed
        var: A tuple of an argument name and some iterable object
    &#34;&#34;&#34;

    def __init__(self, consts: Dict = None, var: List[Tuple[str, List]] = None) -&gt; None:
        if len(var):
            if any([i in consts for i in _sb_rnames]) or (var[0] in _sb_rnames):
                raise Exception(
                    &#34;Cannot use a reserved name for a variable {}&#34;.format(
                        pformat(_sb_rnames)
                    )
                )
            for vals in var:
                if vals[0] in consts:
                    raise Exception(
                        &#34;Name defined as constant and varying: {}&#34;.format(vals[0])
                    )

        self.consts = consts
        self.var = var

    def produce_args(self) -&gt; List[Dict]:
        &#34;&#34;&#34;Produces a list of arguments given the consts and vars
        Example:
            Variables(
                sb.Variables(
                    consts = {
                        &#34;other&#34; : 1
                    },
                    var = [(&#34;x&#34; ,range(0, 3, 1)), (&#34;test&#34;, range(0, 5, 2))]
                ),

            In this example this would produce args as follows:
                { other = 1, x = 0, test = 0},
                { other = 1, x = 0, test = 2},
                { other = 1, x = 0, test = 4},
                { other = 1, x = 1, test = 0},
                ...
                { other = 1, x = 2, test = 4},
        &#34;&#34;&#34;
        if not len(self.var):
            return [dict(self.consts)]

        key_names, ranges = zip(*self.var)
        args = []
        for perm in itertools.product(*ranges):
            run_vars = dict(self.consts)
            for i, k in enumerate(key_names):
                run_vars[k] = perm[i]
            args.append(run_vars)

        return args

    def param_exists(self, name: str) -&gt; bool:
        &#34;&#34;&#34;Checks if a variable is defined either as a constant or a varrying variable&#34;&#34;&#34;
        return (name in self.consts) or any([name == x[0] for x in self.var])

    def y_names(self) -&gt; List[str]:
        &#34;&#34;&#34;Returns the names of varrying or responding variables&#34;&#34;&#34;
        return [x[0] for x in self.var]

    def const_names(self) -&gt; List[str]:
        &#34;&#34;&#34;Returns names of constants&#34;&#34;&#34;
        return self.consts.keys()

    def __repr__(self) -&gt; str:
        return pformat(vars(self), width=30)


class Backend:
    def __init__(self, path, variables):
        self.backends = path.split(&#34;/&#34;)
        self.runtime_variables = variables

    @staticmethod
    def user_to_sql(path):
        return &#34;_b_&#34;.join(path.split(&#34;/&#34;))

    @staticmethod
    def user_to_out(path):
        return &#34;-&#34;.join(path.split(&#34;/&#34;))

    @staticmethod
    def out_to_user(path):
        return &#34;/&#34;.join(path.split(&#34;-&#34;))

    @staticmethod
    def out_to_sql(path):
        return &#34;_b_&#34;.join(path.split(&#34;-&#34;))

    @property
    def path_sql(self):
        return &#34;_b_&#34;.join(self.backends)

    @property
    def path_user(self):
        return &#34;/&#34;.join(self.backends)

    @property
    def path_out(self):
        return &#34;-&#34;.join(self.backends)

    def __eq__(self, path):
        return (
            (self.path_sql == path)
            or (self.path_out == path)
            or (self.path_user == path)
        )


class ExecutionStub:
    def __init__(self, **kwargs):
        metric = Metrics()
        for k, v in kwargs.items():
            metric.add_constant(k, v)
        self._cached = [metric]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="progbg.util.dump_obj"><code class="name flex">
<span>def <span class="ident">dump_obj</span></span>(<span>file: str, obj: Dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Dump dictionary to file key=val</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump_obj(file: str, obj: Dict):
    &#34;&#34;&#34;Dump dictionary to file key=val&#34;&#34;&#34;
    with open(file, &#34;w&#34;) as ofile:
        for key, val in obj.items():
            line = &#34;{}={}\n&#34;.format(key, val)
            ofile.write(line)</code></pre>
</details>
</dd>
<dt id="progbg.util.error"><code class="name flex">
<span>def <span class="ident">error</span></span>(<span>strn: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def error(strn: str):
    print(&#34;\033[0;31m[Error]:\033[0m {}&#34;.format(strn))
    sys.exit(-1)</code></pre>
</details>
</dd>
<dt id="progbg.util.normalize"><code class="name flex">
<span>def <span class="ident">normalize</span></span>(<span>group_list, index_to)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize(group_list, index_to):
    normal = group_list[index_to]
    final_list = []
    for group in group_list:
        stddev = group[1] / group[0]
        newval = group[0] / normal[0]
        final_list.append((newval, stddev * newval))
    return final_list</code></pre>
</details>
</dd>
<dt id="progbg.util.restore_print"><code class="name flex">
<span>def <span class="ident">restore_print</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def restore_print():
    sys.stdout.close()
    sys.stdout = sys.__stdout__</code></pre>
</details>
</dd>
<dt id="progbg.util.retrieve_obj"><code class="name flex">
<span>def <span class="ident">retrieve_obj</span></span>(<span>file: str) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve dictionary from file key=val</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retrieve_obj(file: str) -&gt; Dict:
    &#34;&#34;&#34;Retrieve dictionary from file key=val&#34;&#34;&#34;
    obj = {}
    with open(file, &#34;r&#34;) as ofile:
        for line in ofile.readlines():
            vals = line.strip().split(&#34;=&#34;)
            try:
                obj[vals[0]] = vals[1]
            except:
                print(&#34;Issue with file: {}&#34;.format(file))
                exit(0)
    return obj</code></pre>
</details>
</dd>
<dt id="progbg.util.silence_print"><code class="name flex">
<span>def <span class="ident">silence_print</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def silence_print():
    sys.stdout = open(os.devnull, &#34;w&#34;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="progbg.util.Backend"><code class="flex name class">
<span>class <span class="ident">Backend</span></span>
<span>(</span><span>path, variables)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Backend:
    def __init__(self, path, variables):
        self.backends = path.split(&#34;/&#34;)
        self.runtime_variables = variables

    @staticmethod
    def user_to_sql(path):
        return &#34;_b_&#34;.join(path.split(&#34;/&#34;))

    @staticmethod
    def user_to_out(path):
        return &#34;-&#34;.join(path.split(&#34;/&#34;))

    @staticmethod
    def out_to_user(path):
        return &#34;/&#34;.join(path.split(&#34;-&#34;))

    @staticmethod
    def out_to_sql(path):
        return &#34;_b_&#34;.join(path.split(&#34;-&#34;))

    @property
    def path_sql(self):
        return &#34;_b_&#34;.join(self.backends)

    @property
    def path_user(self):
        return &#34;/&#34;.join(self.backends)

    @property
    def path_out(self):
        return &#34;-&#34;.join(self.backends)

    def __eq__(self, path):
        return (
            (self.path_sql == path)
            or (self.path_out == path)
            or (self.path_user == path)
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="progbg.util.Backend.out_to_sql"><code class="name flex">
<span>def <span class="ident">out_to_sql</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def out_to_sql(path):
    return &#34;_b_&#34;.join(path.split(&#34;-&#34;))</code></pre>
</details>
</dd>
<dt id="progbg.util.Backend.out_to_user"><code class="name flex">
<span>def <span class="ident">out_to_user</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def out_to_user(path):
    return &#34;/&#34;.join(path.split(&#34;-&#34;))</code></pre>
</details>
</dd>
<dt id="progbg.util.Backend.user_to_out"><code class="name flex">
<span>def <span class="ident">user_to_out</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def user_to_out(path):
    return &#34;-&#34;.join(path.split(&#34;/&#34;))</code></pre>
</details>
</dd>
<dt id="progbg.util.Backend.user_to_sql"><code class="name flex">
<span>def <span class="ident">user_to_sql</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def user_to_sql(path):
    return &#34;_b_&#34;.join(path.split(&#34;/&#34;))</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="progbg.util.Backend.path_out"><code class="name">var <span class="ident">path_out</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def path_out(self):
    return &#34;-&#34;.join(self.backends)</code></pre>
</details>
</dd>
<dt id="progbg.util.Backend.path_sql"><code class="name">var <span class="ident">path_sql</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def path_sql(self):
    return &#34;_b_&#34;.join(self.backends)</code></pre>
</details>
</dd>
<dt id="progbg.util.Backend.path_user"><code class="name">var <span class="ident">path_user</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def path_user(self):
    return &#34;/&#34;.join(self.backends)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="progbg.util.ExecutionStub"><code class="flex name class">
<span>class <span class="ident">ExecutionStub</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExecutionStub:
    def __init__(self, **kwargs):
        metric = Metrics()
        for k, v in kwargs.items():
            metric.add_constant(k, v)
        self._cached = [metric]</code></pre>
</details>
</dd>
<dt id="progbg.util.Metrics"><code class="flex name class">
<span>class <span class="ident">Metrics</span></span>
</code></dt>
<dd>
<div class="desc"><p>Metrics collection object</p>
<p>This object is given to executions to allow for users to specify what data
must be kept. The main functio that should be used by users is the add_metric
function, which simply appends data points to a list to be used to calculate
means and standard deviation later</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Metrics:
    &#34;&#34;&#34;Metrics collection object

    This object is given to executions to allow for users to specify what data
    must be kept. The main functio that should be used by users is the add_metric
    function, which simply appends data points to a list to be used to calculate
    means and standard deviation later
    &#34;&#34;&#34;

    def __init__(self):
        self._vars = dict()
        self._consts = dict()

    def add_metric(self, key, val):
        &#34;&#34;&#34;Add a data point to a metric key

        Args:
            key (str): Key to add value to
            val (int, float): value to append to a list

        Example:
            Suppose we have a parser we wish to use. This parser takes
            both a metrics object and a file path.

            &gt;&gt;&gt; def my_parser(metrics: Metrics, out: str):
            &gt;&gt;&gt;     with open(out, &#39;r&#39;) as f:
            &gt;&gt;&gt;         mydata = f.read()
            &gt;&gt;&gt;         val = find_specific_value(mydata)
            &gt;&gt;&gt;         metrics.add_metric(&#39;my-stored-val&#39;, val)
        &#34;&#34;&#34;
        if key not in self._vars:
            self._vars[key] = [val]
        else:
            self._vars[key].append(val)

    def to_file(self, path):
        stats = self.get_stats()
        with open(path, &#34;w&#34;) as f:
            for k, val in stats.items():
                f.write(&#34;{}={}\n&#34;.format(k, val))

    def add_metrics(self, key, vals):
        for v in vals:
            self.add_metric(key, v)

    def stat(self, key):
        obj = self.get_stats()
        return obj[key]

    def __getitem__(self, key):
        obj = self.get_stats()
        if key in self._vars:
            return self._vars[key]

        return self._consts[key]

    def __contains__(self, key):
        return (key in self._vars) or (key in self._consts)

    def add_constant(self, key, val):
        &#34;&#34;&#34;Add a constant to a metric object

        Args:
            key (str): Key for constant
            val (obj): Value of this constant
        &#34;&#34;&#34;
        self._consts[key] = val

    def _combine(self, other: Dict):
        for key, val in other._vars.items():
            if key in self._vars:
                self._vars[key].append(val)
            else:
                self._vars[key] = val

    def get_stats(self):
        &#34;&#34;&#34;Returns the metrics object

        Will return the current metrics of this object. Each associated
        key will have its mean and standard deviation calculated.  Standard deviation
        is stored within a &#34;_std&#34; key.

        For example. If I had some metrics with associated key &#34;my-metric&#34;. The returned
        dictionary would store the mean at key &#34;my-metrics&#34;, and store standard deviation
        at key &#34;my-metrics_std&#34;.  This allows users to also manually set standard deviation
        of objects if needed. For example when using then `plan_parse` style executions.

        Returns:
            dict
        &#34;&#34;&#34;
        obj = dict()
        for key, val in self._vars.items():
            obj[key] = np.mean(val)
            obj[key + &#34;_std&#34;] = np.std(val)
        for key, val in self._consts.items():
            obj[key] = val

        return obj

    def __repr__(self):
        obj = self.get_stats()
        return pformat(obj)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="progbg.util.Metrics.add_constant"><code class="name flex">
<span>def <span class="ident">add_constant</span></span>(<span>self, key, val)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a constant to a metric object</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>Key for constant</dd>
<dt><strong><code>val</code></strong> :&ensp;<code>obj</code></dt>
<dd>Value of this constant</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_constant(self, key, val):
    &#34;&#34;&#34;Add a constant to a metric object

    Args:
        key (str): Key for constant
        val (obj): Value of this constant
    &#34;&#34;&#34;
    self._consts[key] = val</code></pre>
</details>
</dd>
<dt id="progbg.util.Metrics.add_metric"><code class="name flex">
<span>def <span class="ident">add_metric</span></span>(<span>self, key, val)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a data point to a metric key</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>Key to add value to</dd>
<dt><strong><code>val</code></strong> :&ensp;<code>int, float</code></dt>
<dd>value to append to a list</dd>
</dl>
<h2 id="example">Example</h2>
<p>Suppose we have a parser we wish to use. This parser takes
both a metrics object and a file path.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; def my_parser(metrics: Metrics, out: str):
&gt;&gt;&gt;     with open(out, 'r') as f:
&gt;&gt;&gt;         mydata = f.read()
&gt;&gt;&gt;         val = find_specific_value(mydata)
&gt;&gt;&gt;         metrics.add_metric('my-stored-val', val)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_metric(self, key, val):
    &#34;&#34;&#34;Add a data point to a metric key

    Args:
        key (str): Key to add value to
        val (int, float): value to append to a list

    Example:
        Suppose we have a parser we wish to use. This parser takes
        both a metrics object and a file path.

        &gt;&gt;&gt; def my_parser(metrics: Metrics, out: str):
        &gt;&gt;&gt;     with open(out, &#39;r&#39;) as f:
        &gt;&gt;&gt;         mydata = f.read()
        &gt;&gt;&gt;         val = find_specific_value(mydata)
        &gt;&gt;&gt;         metrics.add_metric(&#39;my-stored-val&#39;, val)
    &#34;&#34;&#34;
    if key not in self._vars:
        self._vars[key] = [val]
    else:
        self._vars[key].append(val)</code></pre>
</details>
</dd>
<dt id="progbg.util.Metrics.add_metrics"><code class="name flex">
<span>def <span class="ident">add_metrics</span></span>(<span>self, key, vals)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_metrics(self, key, vals):
    for v in vals:
        self.add_metric(key, v)</code></pre>
</details>
</dd>
<dt id="progbg.util.Metrics.get_stats"><code class="name flex">
<span>def <span class="ident">get_stats</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the metrics object</p>
<p>Will return the current metrics of this object. Each associated
key will have its mean and standard deviation calculated.
Standard deviation
is stored within a "_std" key.</p>
<p>For example. If I had some metrics with associated key "my-metric". The returned
dictionary would store the mean at key "my-metrics", and store standard deviation
at key "my-metrics_std".
This allows users to also manually set standard deviation
of objects if needed. For example when using then <code>plan_parse</code> style executions.</p>
<h2 id="returns">Returns</h2>
<p>dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_stats(self):
    &#34;&#34;&#34;Returns the metrics object

    Will return the current metrics of this object. Each associated
    key will have its mean and standard deviation calculated.  Standard deviation
    is stored within a &#34;_std&#34; key.

    For example. If I had some metrics with associated key &#34;my-metric&#34;. The returned
    dictionary would store the mean at key &#34;my-metrics&#34;, and store standard deviation
    at key &#34;my-metrics_std&#34;.  This allows users to also manually set standard deviation
    of objects if needed. For example when using then `plan_parse` style executions.

    Returns:
        dict
    &#34;&#34;&#34;
    obj = dict()
    for key, val in self._vars.items():
        obj[key] = np.mean(val)
        obj[key + &#34;_std&#34;] = np.std(val)
    for key, val in self._consts.items():
        obj[key] = val

    return obj</code></pre>
</details>
</dd>
<dt id="progbg.util.Metrics.stat"><code class="name flex">
<span>def <span class="ident">stat</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stat(self, key):
    obj = self.get_stats()
    return obj[key]</code></pre>
</details>
</dd>
<dt id="progbg.util.Metrics.to_file"><code class="name flex">
<span>def <span class="ident">to_file</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_file(self, path):
    stats = self.get_stats()
    with open(path, &#34;w&#34;) as f:
        for k, val in stats.items():
            f.write(&#34;{}={}\n&#34;.format(k, val))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="progbg.util.Variables"><code class="flex name class">
<span>class <span class="ident">Variables</span></span>
<span>(</span><span>consts: Dict = None, var: List[Tuple[str, List]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Variables is a container class for variables for a given execution</p>
<p>This will define the permutations that can occur for those that utilize the
class (see Variables.produce_args documentation)</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>const</code></strong></dt>
<dd>A dictionary of argument names to values that will be passed</dd>
<dt><strong><code>var</code></strong></dt>
<dd>A tuple of an argument name and some iterable object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Variables:
    &#34;&#34;&#34;
    Variables is a container class for variables for a given execution

    This will define the permutations that can occur for those that utilize the
    class (see Variables.produce_args documentation)

    Attributes:
        const: A dictionary of argument names to values that will be passed
        var: A tuple of an argument name and some iterable object
    &#34;&#34;&#34;

    def __init__(self, consts: Dict = None, var: List[Tuple[str, List]] = None) -&gt; None:
        if len(var):
            if any([i in consts for i in _sb_rnames]) or (var[0] in _sb_rnames):
                raise Exception(
                    &#34;Cannot use a reserved name for a variable {}&#34;.format(
                        pformat(_sb_rnames)
                    )
                )
            for vals in var:
                if vals[0] in consts:
                    raise Exception(
                        &#34;Name defined as constant and varying: {}&#34;.format(vals[0])
                    )

        self.consts = consts
        self.var = var

    def produce_args(self) -&gt; List[Dict]:
        &#34;&#34;&#34;Produces a list of arguments given the consts and vars
        Example:
            Variables(
                sb.Variables(
                    consts = {
                        &#34;other&#34; : 1
                    },
                    var = [(&#34;x&#34; ,range(0, 3, 1)), (&#34;test&#34;, range(0, 5, 2))]
                ),

            In this example this would produce args as follows:
                { other = 1, x = 0, test = 0},
                { other = 1, x = 0, test = 2},
                { other = 1, x = 0, test = 4},
                { other = 1, x = 1, test = 0},
                ...
                { other = 1, x = 2, test = 4},
        &#34;&#34;&#34;
        if not len(self.var):
            return [dict(self.consts)]

        key_names, ranges = zip(*self.var)
        args = []
        for perm in itertools.product(*ranges):
            run_vars = dict(self.consts)
            for i, k in enumerate(key_names):
                run_vars[k] = perm[i]
            args.append(run_vars)

        return args

    def param_exists(self, name: str) -&gt; bool:
        &#34;&#34;&#34;Checks if a variable is defined either as a constant or a varrying variable&#34;&#34;&#34;
        return (name in self.consts) or any([name == x[0] for x in self.var])

    def y_names(self) -&gt; List[str]:
        &#34;&#34;&#34;Returns the names of varrying or responding variables&#34;&#34;&#34;
        return [x[0] for x in self.var]

    def const_names(self) -&gt; List[str]:
        &#34;&#34;&#34;Returns names of constants&#34;&#34;&#34;
        return self.consts.keys()

    def __repr__(self) -&gt; str:
        return pformat(vars(self), width=30)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="progbg.util.Variables.const_names"><code class="name flex">
<span>def <span class="ident">const_names</span></span>(<span>self) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns names of constants</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def const_names(self) -&gt; List[str]:
    &#34;&#34;&#34;Returns names of constants&#34;&#34;&#34;
    return self.consts.keys()</code></pre>
</details>
</dd>
<dt id="progbg.util.Variables.param_exists"><code class="name flex">
<span>def <span class="ident">param_exists</span></span>(<span>self, name: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if a variable is defined either as a constant or a varrying variable</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def param_exists(self, name: str) -&gt; bool:
    &#34;&#34;&#34;Checks if a variable is defined either as a constant or a varrying variable&#34;&#34;&#34;
    return (name in self.consts) or any([name == x[0] for x in self.var])</code></pre>
</details>
</dd>
<dt id="progbg.util.Variables.produce_args"><code class="name flex">
<span>def <span class="ident">produce_args</span></span>(<span>self) ‑> List[Dict]</span>
</code></dt>
<dd>
<div class="desc"><p>Produces a list of arguments given the consts and vars</p>
<h2 id="example">Example</h2>
<p>Variables(
sb.Variables(
consts = {
"other" : 1
},
var = [("x" ,range(0, 3, 1)), ("test", range(0, 5, 2))]
),</p>
<p>In this example this would produce args as follows:
{ other = 1, x = 0, test = 0},
{ other = 1, x = 0, test = 2},
{ other = 1, x = 0, test = 4},
{ other = 1, x = 1, test = 0},
&hellip;
{ other = 1, x = 2, test = 4},</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def produce_args(self) -&gt; List[Dict]:
    &#34;&#34;&#34;Produces a list of arguments given the consts and vars
    Example:
        Variables(
            sb.Variables(
                consts = {
                    &#34;other&#34; : 1
                },
                var = [(&#34;x&#34; ,range(0, 3, 1)), (&#34;test&#34;, range(0, 5, 2))]
            ),

        In this example this would produce args as follows:
            { other = 1, x = 0, test = 0},
            { other = 1, x = 0, test = 2},
            { other = 1, x = 0, test = 4},
            { other = 1, x = 1, test = 0},
            ...
            { other = 1, x = 2, test = 4},
    &#34;&#34;&#34;
    if not len(self.var):
        return [dict(self.consts)]

    key_names, ranges = zip(*self.var)
    args = []
    for perm in itertools.product(*ranges):
        run_vars = dict(self.consts)
        for i, k in enumerate(key_names):
            run_vars[k] = perm[i]
        args.append(run_vars)

    return args</code></pre>
</details>
</dd>
<dt id="progbg.util.Variables.y_names"><code class="name flex">
<span>def <span class="ident">y_names</span></span>(<span>self) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the names of varrying or responding variables</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def y_names(self) -&gt; List[str]:
    &#34;&#34;&#34;Returns the names of varrying or responding variables&#34;&#34;&#34;
    return [x[0] for x in self.var]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="progbg" href="index.html">progbg</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="progbg.util.dump_obj" href="#progbg.util.dump_obj">dump_obj</a></code></li>
<li><code><a title="progbg.util.error" href="#progbg.util.error">error</a></code></li>
<li><code><a title="progbg.util.normalize" href="#progbg.util.normalize">normalize</a></code></li>
<li><code><a title="progbg.util.restore_print" href="#progbg.util.restore_print">restore_print</a></code></li>
<li><code><a title="progbg.util.retrieve_obj" href="#progbg.util.retrieve_obj">retrieve_obj</a></code></li>
<li><code><a title="progbg.util.silence_print" href="#progbg.util.silence_print">silence_print</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="progbg.util.Backend" href="#progbg.util.Backend">Backend</a></code></h4>
<ul class="two-column">
<li><code><a title="progbg.util.Backend.out_to_sql" href="#progbg.util.Backend.out_to_sql">out_to_sql</a></code></li>
<li><code><a title="progbg.util.Backend.out_to_user" href="#progbg.util.Backend.out_to_user">out_to_user</a></code></li>
<li><code><a title="progbg.util.Backend.path_out" href="#progbg.util.Backend.path_out">path_out</a></code></li>
<li><code><a title="progbg.util.Backend.path_sql" href="#progbg.util.Backend.path_sql">path_sql</a></code></li>
<li><code><a title="progbg.util.Backend.path_user" href="#progbg.util.Backend.path_user">path_user</a></code></li>
<li><code><a title="progbg.util.Backend.user_to_out" href="#progbg.util.Backend.user_to_out">user_to_out</a></code></li>
<li><code><a title="progbg.util.Backend.user_to_sql" href="#progbg.util.Backend.user_to_sql">user_to_sql</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="progbg.util.ExecutionStub" href="#progbg.util.ExecutionStub">ExecutionStub</a></code></h4>
</li>
<li>
<h4><code><a title="progbg.util.Metrics" href="#progbg.util.Metrics">Metrics</a></code></h4>
<ul class="two-column">
<li><code><a title="progbg.util.Metrics.add_constant" href="#progbg.util.Metrics.add_constant">add_constant</a></code></li>
<li><code><a title="progbg.util.Metrics.add_metric" href="#progbg.util.Metrics.add_metric">add_metric</a></code></li>
<li><code><a title="progbg.util.Metrics.add_metrics" href="#progbg.util.Metrics.add_metrics">add_metrics</a></code></li>
<li><code><a title="progbg.util.Metrics.get_stats" href="#progbg.util.Metrics.get_stats">get_stats</a></code></li>
<li><code><a title="progbg.util.Metrics.stat" href="#progbg.util.Metrics.stat">stat</a></code></li>
<li><code><a title="progbg.util.Metrics.to_file" href="#progbg.util.Metrics.to_file">to_file</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="progbg.util.Variables" href="#progbg.util.Variables">Variables</a></code></h4>
<ul class="">
<li><code><a title="progbg.util.Variables.const_names" href="#progbg.util.Variables.const_names">const_names</a></code></li>
<li><code><a title="progbg.util.Variables.param_exists" href="#progbg.util.Variables.param_exists">param_exists</a></code></li>
<li><code><a title="progbg.util.Variables.produce_args" href="#progbg.util.Variables.produce_args">produce_args</a></code></li>
<li><code><a title="progbg.util.Variables.y_names" href="#progbg.util.Variables.y_names">y_names</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>