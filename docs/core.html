<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>progbg.core API documentation</title>
<meta name="description" content="Core API calls and classes for ProgBG …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>progbg.core</code></h1>
</header>
<section id="section-intro">
<p>Core API calls and classes for ProgBG</p>
<p>This module contains all related API calls for creating and managing
plan.py files. Special global variables are used to keep track
of registered backends and benchmarks.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># pylint: disable-msg=E0611,E0401,C0103,W0703,R0903

&#34;&#34;&#34;Core API calls and classes for ProgBG

This module contains all related API calls for creating and managing
plan.py files. Special global variables are used to keep track
of registered backends and benchmarks.
&#34;&#34;&#34;

import os
import sys
import importlib
import inspect
import sqlite3
import shutil

import types
import subprocess
from typing import List, Dict
from pprint import pformat
from pprint import pprint

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

from .format import format_fig, check_formatter
from .util import Backend, Variables, dump_obj, error
from .util import silence_print, restore_print

from .globals import _sb_registered_benchmarks, _sb_registered_backend
from .globals import _sb_executions, _sb_graphs, _sb_rnames
from .globals import _sb_figures, GRAPHS_DIR
from .globals import _EDIT_GLOBAL_TABLE


class Metrics:
    def __init__(self):
        self._vars = dict()
        self._consts = dict()

    def add_metric(self, key, val):
        if key not in self._vars:
            self._vars[key] = [val]
        else:
            self._vars[key].append(val)

    def __getitem__(self, key):
        if key in self._vars:
            return self._vars[key]

        return self._consts[key]

    def add_constant(self, key, val):
        self._consts[key] = val

    def combinate(self, other: Dict):
        for key, val in other._vars.items():
            if key in self._vars:
                self._vars[key].append(val)
            else:
                self._vars[key] = val

    def get_stats(self):
        obj = dict()
        for key, val in self._vars.items():
            obj[key] = np.mean(val)
            obj[key + &#34;_std&#34;] = np.std(val)
        for key, val in self._consts.items():
            obj[key] = val

        return obj

    def __repr__(self):
        obj = self.get_stats()
        return pformat(obj)


def _retrieve_named_backends(back_obj):
    named = []
    for backend in back_obj.backends:
        cls = _sb_registered_backend[backend]
        required_init = inspect.getfullargspec(cls.init).args
        required_uninit = inspect.getfullargspec(cls.uninit).args
        named.extend(required_init + required_uninit)

    return named


def _retrieve_named_benchmarks(name):
    cls = _sb_registered_benchmarks[name]
    required_run = inspect.getfullargspec(cls.run).args[2:]

    return required_run


def _retrieve_backends(back_obj):
    return [_sb_registered_backend[back] for back in back_obj.backends]


def check_file_backend(file_name):
    &#34;&#34;&#34;Checks what the backend of a given filename is
    Files are orgnized into WORKLOAD_backend_BACKEND_...
    For workloads that don&#39;t used a backend the _backend is
    not there
    &#34;&#34;&#34;
    chunks = file_name.split(&#39;_&#39;)
    if chunks[1] != &#39;_backend&#39;:
        return None

    return chunks[2]


def registerbenchmark_sh(name: str, file_path: str):
    custom_backend = type(name, (object, ), {})

    @staticmethod
    def run(backend, out_file):
        out = open(out_file, &#39;w&#39;)
        shell = subprocess.Popen(&#34;sh&#34;, stdin=subprocess.PIPE, stdout=out)
        script = open(file_path, &#34;r&#34;).read()
        script += &#34;\n&#34;
        shell.stdin.write(str.encode(script))
        script = open(file_path, &#34;r&#34;).read()
        run_str = &#34;run\n&#34;.format(i)
        shell.stdin.write(str.encode(run_str))
        shell.stdin.close()
        shell.wait()

    custom_backend.run = run
    registerbenchmark(custom_backend)


def registerbackend_sh(name: str, file_path: str):
    custom_backend = type(name, (object, ), {})

    @staticmethod
    def init():
        shell = subprocess.Popen(
            &#34;sh&#34;, stdin=subprocess.PIPE, stdout=subprocess.PIPE)
        script = open(file_path, &#34;r&#34;).read()
        script += &#34;\n&#34;
        shell.stdin.write(str.encode(script))
        shell.stdin.write(str.encode(&#34;init &gt; /dev/null\n&#34;))
        shell.stdin.write(str.encode(&#34;env\n&#34;))
        shell.stdin.close()
        environment = dict()
        for line in shell.stdout:
            name, value = line.decode(&#39;ascii&#39;).strip().split(&#39;=&#39;, 1)
            environment[name] = value
        uniq = {k: environment[k] for k in set(environment) - set(os.environ)}
        custom_backend.env = uniq
        shell.wait()

    custom_backend.init = init

    @staticmethod
    def uninit():
        shell = subprocess.Popen(
            &#34;sh&#34;, stdin=subprocess.PIPE, stdout=subprocess.PIPE, env=custom_backend.env)
        script = open(file_path, &#34;r&#34;).read()
        script += &#34;\n&#34;
        shell.stdin.write(str.encode(script))
        shell.stdin.write(str.encode(&#34;uninit\n&#34;))
        shell.stdin.close()
        shell.wait()

    custom_backend.uninit = uninit

    registerbackend(custom_backend)


class NullBackend:
    def __init__(self, consts={}, var=[]):
        self.var = Variables(consts, var)

    @staticmethod
    def init():
        pass

    @staticmethod
    def uninit():
        pass


class Execution:
    &#34;&#34;&#34;Execution class, see plan_execution documentation&#34;&#34;&#34;

    def __init__(self, benchmark, backends: List, parser, out: str):
        self.bench = benchmark

        if backends:
            self.backends = backends
        else:
            self.backends = [NullBackend()]

        self.run_benchmarks = None
        self.out = out
        self.parser = parser
        self._cached = None
        self.name = &#34;,&#34;.join(
            [back.name for back in self.backends]) + &#34;-&#34; + self.bench.name

    def print(self, string):
        &#34;&#34;&#34;Pretty printer for execution&#34;&#34;&#34;
        print(&#34;\033[1;31m[{} - {}]:\033[0m {}&#34;.format(self.name,
                                                      self.bench.name, string))

    def tables(self):
        &#34;&#34;&#34;
        Generates the tables needed for the sqlite backend

        Table names are in the form EXECNAME__BENCHNAME__BACKENDS
        Composed backends are seperated by &#34;_b_&#34;.  This is because characters
        like &#34;/&#34; and &#34;-&#34; and &#34;:&#34; are not accepted by sqlite.
        &#34;&#34;&#34;
        tables = {}
        if self.backends:
            for back_obj in self.backends:
                fields_backends = _retrieve_named_backends(back_obj)
                fields_benchmark = _retrieve_named_benchmarks(self.bench.name)
                fields_parser = self.bench.parser.fields()
                tablename = &#34;{}__{}__{}&#34;.format(self.name,
                                                self.bench.name, back_obj.path_sql)
                fields = fields_backends + fields_benchmark + fields_parser + _sb_rnames
                tables[tablename] = sorted(fields)
        else:
            fields_benchmark = _retrieve_named_benchmarks(self.bench.name)
            fields_parser = self.bench.parser.fields()
            tablename = &#34;{}__{}&#34;.format(self.name,
                                        self.bench.name)
            fields = fields_benchmark + fields_parser + _sb_rnames
            tables[tablename] = sorted(fields)

        return tables

    def _setup_tables(self):
        conn = sqlite3.connect(self.out)
        for name, vals in self.tables.items():
            c = conn.cursor()
            quotes = [&#39;&#34;{}&#34;&#39;.format(val) for val in vals]
            exec_str = &#34;CREATE TABLE {} ({});&#34;.format(name, &#34;,&#34;.join(quotes))
            try:
                c.execute(exec_str)
            except sqlite3.OperationalError:
                exec_str = &#34;DELETE FROM {}&#34;.format(name)
                c.execute(exec_str)
            conn.commit()
            c.close()
        conn.close()

    # Constantly creating the connection is not so nice.
    def _add_sql_row(self, obj, bench_args, full_backend_args):
        conn = sqlite3.connect(self.out)
        c = conn.cursor()
        inserted = False
        for name_full, fields in self.tables.items():
            name = name_full.split(&#39;__&#39;)
            if obj[&#34;_execution_name&#34;] != name[0]:
                continue

            if obj[&#34;_workload&#34;] != name[1]:
                continue

            if len(name) == 3:
                sql_friendly = Backend.out_to_sql(obj[&#34;_backend&#34;])
                if sql_friendly != name[2]:
                    continue

                obj[&#34;_backend&#34;] = sql_friendly

            vals = []
            for val in fields:
                # We have to eliminate the first and last char as they are quotes
                if val in obj:
                    # If we do typing for object we would have to do it here?
                    # When we get the fields we would also ask for typing
                    # Its a feature that will probably need to be added sooner
                    # over later
                    vals.append(&#39;&#34;{}&#34;&#39;.format(str(obj[val])))
                else:
                    if full_backend_args and val in full_backend_args:
                        vals.append(&#39;&#34;{}&#34;&#39;.format(str(full_backend_args[val])))
                    elif val in bench_args:
                        vals.append(&#39;&#34;{}&#34;&#39;.format(str(bench_args[val])))
                    else:
                        vals.append(&#39;&#34;&#34;&#39;)

            quotes = [&#39;&#34;{}&#34;&#39;.format(val.strip()) for val in fields]
            exec_str = &#34;INSERT INTO {} ({})\nVALUES ({});&#34;.format(name_full,
                                                                  &#34;,&#34;.join(quotes), &#34;,&#34;.join(vals))

            c.execute(exec_str)
            conn.commit()
            c.close()
            inserted = True
            break

        conn.close()
        if not inserted:
            raise Exception(&#34;Object was not/could not be added to any table&#34;)

    def clean(self):
        &#34;&#34;&#34;Cleans output directories&#34;&#34;&#34;
        if self.is_sql_backed():
            self._setup_tables()
        else:
            try:
                os.mkdir(self.out)
            except Exception as e:
                if len(os.listdir(self.out)) &gt; 0:
                    self.print(e)
                    self.print(
                        &#34;Problem creating out directory {}, test data already there&#34;.format(self.out))
                    exit(0)

    def _merged_args(self, back_vars):
        benchmark = self.bench.variables.produce_args()
        backend = back_vars.produce_args()
        args = []
        for back in backend:
            arg = dict(
                benchmark=benchmark,
                backend=back
            )
            args.append(arg)

        return args

    def parse(self):
        # Pretty messy having to do this twice but need to retrieve proper data
        if self._cached:
            self.print(&#34;Using cached parsed output&#34;)
            return

        combined = []
        for back in self.backends:
            args = self._merged_args(back.variables)
            for arg_set in args:
                bench_args = arg_set[&#34;benchmark&#34;]
                back_args = arg_set[&#34;backend&#34;]
                for ba in bench_args:
                    metrics = Metrics()
                    for k, v in ba.items():
                        metrics.add_constant(k, v)
                    for k, v in back_args.items():
                        metrics.add_constant(k, v)
                    for iteration in range(0,  self.bench.iterations):
                        out_file = os.path.abspath(self.out_file(back,
                                                                 back_args, ba, iteration))
                        self.parser(metrics, out_file)
                    combined.append(metrics)

        self._cached = combined

    def out_file(self, back_obj, backend_args, bench_args, iteration):
        &#34;&#34;&#34;Determine output filename given a some backend and bench arguments

        output is {Execution_name}_b_{BCK1-BCK2}_{BCKVARS}_{WRKVARS}
        &#34;&#34;&#34;
        file = self.bench.__class__.__name__
        file += &#34;_b_{}&#34;.format(back_obj.name)
        for name in back_obj.variables.y_names():
            file += &#34;_{}&#34;.format(backend_args[name])

        for name in self.bench.variables.y_names():
            file += &#34;_{}&#34;.format(bench_args[name])
        file += &#34;_{}&#34;.format(iteration)

        if self.is_sql_backed():
            return &#34;{}&#34;.format(file)

        return &#34;{}/{}&#34;.format(self.out, file)

    def is_sql_backed(self):
        &#34;&#34;&#34;Checks if execution storage backend is sqlite3&#34;&#34;&#34;
        return self.out.endswith(&#39;.db&#39;)

    def execute(self):
        &#34;&#34;&#34;Execute the execution defined

        Argument:
            args: Arguments namespace from the cli
        &#34;&#34;&#34;
        # Go through every registered backend
        for back in self.backends:
            args = self._merged_args(back.variables)

            # Go through every argument possibility given consts
            # and variables
            for arg_set in args:
                bench_args = arg_set[&#34;benchmark&#34;]
                back_args = arg_set[&#34;backend&#34;]
                back.__class__.start(**back_args)
                # Go through every benchmark argument listing
                for ba in bench_args:
                    for iteration in range(0,  self.bench.iterations):
                        out_file = os.path.abspath(self.out_file(back,
                                                                 back_args, ba, iteration))
                        self.bench.__class__.run(back.name, out_file, **ba)
                back.__class__.uninit()

    def param_exists(self, name: str) -&gt; bool:
        &#34;&#34;&#34;Checks if a param exists within either the benchmark or the parser&#34;&#34;&#34;
        bench_has = self.bench.param_exists(name)
        if self.backends:
            backend_has = any([back_obj.runtime_variables.param_exists(name)
                               for back_obj in self.backends])
        else:
            backend_has = False

        return bench_has or backend_has

    def __str__(self):
        title = self.bench.name + &#34;(&#34;
        for back in self.backends:
            title += &#34;{}&#34;.format(back.name)
        title += &#34;)&#34;
        return &#34;{}&#34;.format(title)


class NoBenchmark:
    def __init__(self, parser):
        self.parser = parser


class ParseExecution:
    def __init__(self, data: str, out_dir: str, func):
        self._data = data
        self.out = out_dir
        self._func = func
        self.bench = NoBenchmark(self)
        self._cached = None

    def fields(self):
        return self._obj.keys()

    def is_sql_backed(self):
        return False

    def param_exists(self, param):
        return True

    def _parse_file(self, metrics, path: str, iter):
        self._func(metrics, path)

    def parse(self):
        if self._cached:
            return

        metrics = Metrics()
        if os.path.isdir(self._data):
            i = 0
            for file in os.listdir(self._data):
                path = os.path.join(self._data, file)
                self._parse_file(metrics, path, i)
                i += 1
        else:
            self._parse_file(metrics, self._data, 0)

        self._cached = [metrics]

    def execute(self):
        pass

    def clean(self):
        pass


def plan_parse(file, parse_file_func, out_dir: str = None):
    _sb_executions.append(ParseExecution(file, out_dir, parse_file_func))
    return _sb_executions[-1]


def compose_backends(*backends):

    def construct(self, consts={}, vars=[]):
        self.variables = Variables(consts, vars)
        self.name = &#34;-&#34;.join([b.__name__ for b in backends])

    def start(**kwargs):
        for backend in backends:
            backend.start(**kwargs)

    def uninit():
        for backend in reversed(backends):
            backend.uninit()

    composition = type(&#34;&#34;, (), {
        &#34;__init__&#34;: construct,
        &#34;start&#34;: start,
        &#34;uninit&#34;: uninit
    })

    return composition


def plan_execution(runner,
                   backends: Dict = None,
                   parser=None,
                   out: str = None) -&gt; None:
    &#34;&#34;&#34;Plan an execution

    Definition of an execution of a workload/benchmark and backends you wish to run the workload
    on.

    Arguments:
        name: Name of the execution, to be used by graph objects to plot data
        run: Running object (DefBenchmark, or Command line benchmark)
        backend: Backends are a dictionary object that tie a backend you wish to run
        (this must be a lowercase name of a registered backend) to a Variables
        object.  This Variables objects holds how you want the backend to change
        for an execution.  See Variables documentation for more info
        parse: A parse object that defines how to take output from a workload,
        and retrieve data.
    &#34;&#34;&#34;

    # We have to fix up the variables, we do this so the user doesnt
    # have to re-input variables twice. Parser also needs to know
    # variable names to create the object
    _sb_executions.append(Execution(runner, backends, parser, out))
    return _sb_executions[-1]


def plan_graph(name: str, graphobj):
    &#34;&#34;&#34;Plan a graph object
    Takes a graph object (LineGraph, etc) and ties the a name to it to be
    used by figures

    Argument:
        name: Name of the graph object - must be unique among all graphs
        graphobj: Graph object to tie to the name
    &#34;&#34;&#34;
    if name in _sb_graphs:
        error(&#34;Graph already defined: {}&#34;.format(name))

    _sb_graphs[name] = graphobj


def _is_static(func):
    return isinstance(func, types.FunctionType)


def _has_required_args(func):
    return len(inspect.getfullargspec(func).args) &gt;= 2


_names_used = []


def _check_names(cls, func, is_run=False):
    if is_run:
        args = inspect.getfullargspec(func).args[2:]
    else:
        args = inspect.getfullargspec(func).args
    for name in args:
        # if name in _names_used:
        # error(&#34;Class &#39;{}&#39;-&gt; function &#39;{}&#39; uses already defined argument name: {}&#34;.format(
        # cls.__name__, func.__name__, name))

        _names_used.append(name)


def registerbenchmark(cls):
    &#34;&#34;&#34;Register for benchmark

    cls: Class definition to wrap and register
    &#34;&#34;&#34;
    if not hasattr(cls, &#34;run&#34;):
        error(&#34;Benchmark requires the run function: {}&#34;.format(cls.__name__))

    if not _has_required_args(cls.run):
        error(&#34;Benchmark run needs 2 argument for output path: {}&#34;.format(cls.__name__))

    _check_names(cls, cls.run, is_run=True)

    def construct(self, consts={}, vars=[], iterations=1):
        self.variables = Variables(consts, vars)
        self.iterations = iterations
        self.name = cls.__name__

    cls.__init__ = construct

    _sb_registered_benchmarks[cls.__name__.lower()] = cls

    return cls


def get_args(spec, **kwargs):
    args = dict()
    for i, k in enumerate(spec.args):
        if k in kwargs:
            args[k] = kwargs[k]
    return args


def registerbackend(cls):
    &#34;&#34;&#34;Regististration of a backend class

    Argument:
    cls: Class definition to wrap and register
    &#34;&#34;&#34;
    if not hasattr(cls, &#34;start&#34;):
        error(&#34;Backend requires the init function: {}&#34;.format(cls.__name__))

    if not hasattr(cls, &#34;uninit&#34;):
        error(&#34;Backend requires the uninit function: {}&#34;.format(cls.__name__))

    _check_names(cls, cls.start)
    _check_names(cls, cls.uninit)

    def construct(self, consts={}, vars=[]):
        self.vars = Variables(consts, vars)
        self.name = cls.__name__

    spec = inspect.getfullargspec(cls.start)
    old = cls.start

    def wrapped_start(**kwargs):
        args = get_args(spec, **kwargs)
        return old(**args)

    cls.__init__ = construct
    cls.start = wrapped_start

    _sb_registered_backend[cls.__name__.lower()] = cls

    return cls


def import_plan(filepath: str, mod_globals):
    &#34;&#34;&#34;Import a .py file to be used by the progbg system
    When the plan is imported, the script is run (all the plan_* function calls)
    this creates and fills global variables within that module. Since modules do
    not share global objects we must edit progbg global table (_EDIT_GLOBAL_TABLE)
    to have these objects as well (figures, graphs, executions)

    Arguments:
        filepath: Path to the .py plan file
        mod_globals: Globals dictionary object (globals())
    &#34;&#34;&#34;
    spec = importlib.util.spec_from_file_location(&#39;_plan&#39;,
                                                  filepath)
    plan_mod = importlib.util.module_from_spec(spec)
    # Different module so different global
    sys.modules[&#34;_plan&#34;] = plan_mod
    spec.loader.exec_module(plan_mod)
    members = inspect.getmembers(plan_mod)
    # We must find the module that was imported in the user given file. This
    # file imports from us, so we must grab that module they imported and
    # set our globals to it.  This is because globals across modules
    # are not unique, meaning each individual module has its own global
    # so to make our &#39;globals&#39; truly global we have to set our
    # globals to theirs
    imported_name = &#34;&#34;
    for name, mod in members:
        if hasattr(mod, &#39;_sb_executions&#39;):
            imported_name = name

    if not imported_name:
        error(&#34;Plan does import progbg: Fix by adding import progbg&#34;)

    # Fix globals in our namespace
    for name in _EDIT_GLOBAL_TABLE:
        mod_globals[name] = getattr(getattr(plan_mod, imported_name), name)


class Figure:
    &#34;&#34;&#34;Create figure given a set of graphs, for more information see plan_figure documentation&#34;&#34;&#34;

    def __init__(self,
                 name: str,
                 graphs: List[List[str]],
                 formatter,
                 out: str):
        check_formatter(formatter)

        self.name = name
        self.graphs = graphs
        self.formatter = formatter
        self.out = out

    def print(self, strn: str) -&gt; None:
        &#34;&#34;&#34;Pretty print function&#34;&#34;&#34;
        print(&#34;\033[1;35m[{}]:\033[0m {}&#34;.format(self.out, strn))

    def create(self):
        &#34;&#34;&#34;Create the figure&#34;&#34;&#34;
        self.print(&#34;Creating Figure&#34;)
        h = len(self.graphs)
        w = len(self.graphs[0])
        fig, axes = plt.subplots(ncols=w, nrows=h, squeeze=False)
        for y in range(0, h):
            for x in range(0, w):
                graph = _sb_graphs[self.graphs[y][x]]
                try:
                    graph.graph(axes[y][x], silent=True)
                except Exception as err:
                    error(&#34;Problem with graph {}: {}&#34;.format(self.name, err))

        format_fig(fig, axes, self.formatter)

        out = os.path.join(GRAPHS_DIR, self.out)
        plt.savefig(out, bbox_inches=&#34;tight&#34;, pad_inches=0)
        if not out.endswith(&#34;.svg&#34;):
            out = &#34;.&#34;.join(out.split(&#34;.&#34;)[:-1]) + &#34;.svg&#34;
            plt.savefig(out, bbox_inches=&#34;tight&#34;, pad_inches=0)


def plan_figure(name: str, graph_layout: List[List[str]], formatter, out: str):
    &#34;&#34;&#34;Plan a figure given a set of graphs
    Arguments:
        name: Unique name for the figure (unique among figures)
        graph_layout: An m x n matrix that defines how you want you
        figure to hold graph objects
        formatter: Formatter object that tells you how to format the
        object this can be either a Dict or a function that takes the figure,
        and axes as an argument (as defined by matplotlib)
        out: output name for the figure.
    Examples:
            sb.plan_figure(&#34;fig-1&#34;,
                    [[&#34;graph-1&#34;],
                    [&#34;graph-2&#34;]],
                    {
                        &#34;height&#34;: 6,
                        &#34;width&#34;: 3,
                    },
                    out  = &#34;samplefig.svg&#34;
            )

            We See here this will create a 1 by 2 matrix where the first row will contain graph-1
            and the second will contain graph 2

            The figure will be modified to have a figure height of 6, and width of 3 and saved to
            sampelefig.svg
    &#34;&#34;&#34;
    if name in _sb_figures:
        error(&#34;Figure already defined: {}&#34;.format(name))

    _sb_figures[name] = Figure(name, graph_layout, formatter, out)


def execute_plan(plan: str, args):
    &#34;&#34;&#34;Entry point to start executing progbg
    Argument:
        plan: Path to plan .py file
        no_exec: When true, will not execute any planned execution but rather will only
        take re-parse and re-make graphs
    &#34;&#34;&#34;
    import_plan(plan, globals())

    if not args.no_exec:
        for execution in _sb_executions:
            execution.clean()

    if not args.no_exec:
        for execution in _sb_executions:
            execution.execute()

    for execution in _sb_executions:
        execution.parse()

    try:
        os.mkdir(GRAPHS_DIR)
    except FileExistsError:
        pass

    for graph in _sb_graphs.values():
        if len(graph.out):
            fig, axes = plt.subplots()
            fig.set_size_inches(3.25, 3.25)
            graph.graph(axes)
            format_fig(fig, axes, graph.formatter)
            for curout in graph.out:
                out = os.path.join(GRAPHS_DIR, curout)
                try:
                    plt.savefig(out)
                except:
                    print(&#34;Problem with output {}&#34;.format(out))

    for fig in _sb_figures.values():
        fig.create()

    return globals()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="progbg.core.check_file_backend"><code class="name flex">
<span>def <span class="ident">check_file_backend</span></span>(<span>file_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks what the backend of a given filename is
Files are orgnized into WORKLOAD_backend_BACKEND_&hellip;
For workloads that don't used a backend the _backend is
not there</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_file_backend(file_name):
    &#34;&#34;&#34;Checks what the backend of a given filename is
    Files are orgnized into WORKLOAD_backend_BACKEND_...
    For workloads that don&#39;t used a backend the _backend is
    not there
    &#34;&#34;&#34;
    chunks = file_name.split(&#39;_&#39;)
    if chunks[1] != &#39;_backend&#39;:
        return None

    return chunks[2]</code></pre>
</details>
</dd>
<dt id="progbg.core.compose_backends"><code class="name flex">
<span>def <span class="ident">compose_backends</span></span>(<span>*backends)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compose_backends(*backends):

    def construct(self, consts={}, vars=[]):
        self.variables = Variables(consts, vars)
        self.name = &#34;-&#34;.join([b.__name__ for b in backends])

    def start(**kwargs):
        for backend in backends:
            backend.start(**kwargs)

    def uninit():
        for backend in reversed(backends):
            backend.uninit()

    composition = type(&#34;&#34;, (), {
        &#34;__init__&#34;: construct,
        &#34;start&#34;: start,
        &#34;uninit&#34;: uninit
    })

    return composition</code></pre>
</details>
</dd>
<dt id="progbg.core.execute_plan"><code class="name flex">
<span>def <span class="ident">execute_plan</span></span>(<span>plan: str, args)</span>
</code></dt>
<dd>
<div class="desc"><p>Entry point to start executing progbg</p>
<h2 id="argument">Argument</h2>
<p>plan: Path to plan .py file
no_exec: When true, will not execute any planned execution but rather will only
take re-parse and re-make graphs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute_plan(plan: str, args):
    &#34;&#34;&#34;Entry point to start executing progbg
    Argument:
        plan: Path to plan .py file
        no_exec: When true, will not execute any planned execution but rather will only
        take re-parse and re-make graphs
    &#34;&#34;&#34;
    import_plan(plan, globals())

    if not args.no_exec:
        for execution in _sb_executions:
            execution.clean()

    if not args.no_exec:
        for execution in _sb_executions:
            execution.execute()

    for execution in _sb_executions:
        execution.parse()

    try:
        os.mkdir(GRAPHS_DIR)
    except FileExistsError:
        pass

    for graph in _sb_graphs.values():
        if len(graph.out):
            fig, axes = plt.subplots()
            fig.set_size_inches(3.25, 3.25)
            graph.graph(axes)
            format_fig(fig, axes, graph.formatter)
            for curout in graph.out:
                out = os.path.join(GRAPHS_DIR, curout)
                try:
                    plt.savefig(out)
                except:
                    print(&#34;Problem with output {}&#34;.format(out))

    for fig in _sb_figures.values():
        fig.create()

    return globals()</code></pre>
</details>
</dd>
<dt id="progbg.core.get_args"><code class="name flex">
<span>def <span class="ident">get_args</span></span>(<span>spec, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_args(spec, **kwargs):
    args = dict()
    for i, k in enumerate(spec.args):
        if k in kwargs:
            args[k] = kwargs[k]
    return args</code></pre>
</details>
</dd>
<dt id="progbg.core.import_plan"><code class="name flex">
<span>def <span class="ident">import_plan</span></span>(<span>filepath: str, mod_globals)</span>
</code></dt>
<dd>
<div class="desc"><p>Import a .py file to be used by the progbg system
When the plan is imported, the script is run (all the plan_* function calls)
this creates and fills global variables within that module. Since modules do
not share global objects we must edit progbg global table (_EDIT_GLOBAL_TABLE)
to have these objects as well (figures, graphs, executions)</p>
<h2 id="arguments">Arguments</h2>
<p>filepath: Path to the .py plan file
mod_globals: Globals dictionary object (globals())</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def import_plan(filepath: str, mod_globals):
    &#34;&#34;&#34;Import a .py file to be used by the progbg system
    When the plan is imported, the script is run (all the plan_* function calls)
    this creates and fills global variables within that module. Since modules do
    not share global objects we must edit progbg global table (_EDIT_GLOBAL_TABLE)
    to have these objects as well (figures, graphs, executions)

    Arguments:
        filepath: Path to the .py plan file
        mod_globals: Globals dictionary object (globals())
    &#34;&#34;&#34;
    spec = importlib.util.spec_from_file_location(&#39;_plan&#39;,
                                                  filepath)
    plan_mod = importlib.util.module_from_spec(spec)
    # Different module so different global
    sys.modules[&#34;_plan&#34;] = plan_mod
    spec.loader.exec_module(plan_mod)
    members = inspect.getmembers(plan_mod)
    # We must find the module that was imported in the user given file. This
    # file imports from us, so we must grab that module they imported and
    # set our globals to it.  This is because globals across modules
    # are not unique, meaning each individual module has its own global
    # so to make our &#39;globals&#39; truly global we have to set our
    # globals to theirs
    imported_name = &#34;&#34;
    for name, mod in members:
        if hasattr(mod, &#39;_sb_executions&#39;):
            imported_name = name

    if not imported_name:
        error(&#34;Plan does import progbg: Fix by adding import progbg&#34;)

    # Fix globals in our namespace
    for name in _EDIT_GLOBAL_TABLE:
        mod_globals[name] = getattr(getattr(plan_mod, imported_name), name)</code></pre>
</details>
</dd>
<dt id="progbg.core.plan_execution"><code class="name flex">
<span>def <span class="ident">plan_execution</span></span>(<span>runner, backends: Dict = None, parser=None, out: str = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Plan an execution</p>
<p>Definition of an execution of a workload/benchmark and backends you wish to run the workload
on.</p>
<h2 id="arguments">Arguments</h2>
<p>name: Name of the execution, to be used by graph objects to plot data
run: Running object (DefBenchmark, or Command line benchmark)
backend: Backends are a dictionary object that tie a backend you wish to run
(this must be a lowercase name of a registered backend) to a Variables
object.
This Variables objects holds how you want the backend to change
for an execution.
See Variables documentation for more info
parse: A parse object that defines how to take output from a workload,
and retrieve data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plan_execution(runner,
                   backends: Dict = None,
                   parser=None,
                   out: str = None) -&gt; None:
    &#34;&#34;&#34;Plan an execution

    Definition of an execution of a workload/benchmark and backends you wish to run the workload
    on.

    Arguments:
        name: Name of the execution, to be used by graph objects to plot data
        run: Running object (DefBenchmark, or Command line benchmark)
        backend: Backends are a dictionary object that tie a backend you wish to run
        (this must be a lowercase name of a registered backend) to a Variables
        object.  This Variables objects holds how you want the backend to change
        for an execution.  See Variables documentation for more info
        parse: A parse object that defines how to take output from a workload,
        and retrieve data.
    &#34;&#34;&#34;

    # We have to fix up the variables, we do this so the user doesnt
    # have to re-input variables twice. Parser also needs to know
    # variable names to create the object
    _sb_executions.append(Execution(runner, backends, parser, out))
    return _sb_executions[-1]</code></pre>
</details>
</dd>
<dt id="progbg.core.plan_figure"><code class="name flex">
<span>def <span class="ident">plan_figure</span></span>(<span>name: str, graph_layout: List[List[str]], formatter, out: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Plan a figure given a set of graphs</p>
<h2 id="arguments">Arguments</h2>
<p>name: Unique name for the figure (unique among figures)
graph_layout: An m x n matrix that defines how you want you
figure to hold graph objects
formatter: Formatter object that tells you how to format the
object this can be either a Dict or a function that takes the figure,
and axes as an argument (as defined by matplotlib)
out: output name for the figure.</p>
<h2 id="examples">Examples</h2>
<p>sb.plan_figure("fig-1",
[["graph-1"],
["graph-2"]],
{
"height": 6,
"width": 3,
},
out
= "samplefig.svg"
)</p>
<p>We See here this will create a 1 by 2 matrix where the first row will contain graph-1
and the second will contain graph 2</p>
<p>The figure will be modified to have a figure height of 6, and width of 3 and saved to
sampelefig.svg</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plan_figure(name: str, graph_layout: List[List[str]], formatter, out: str):
    &#34;&#34;&#34;Plan a figure given a set of graphs
    Arguments:
        name: Unique name for the figure (unique among figures)
        graph_layout: An m x n matrix that defines how you want you
        figure to hold graph objects
        formatter: Formatter object that tells you how to format the
        object this can be either a Dict or a function that takes the figure,
        and axes as an argument (as defined by matplotlib)
        out: output name for the figure.
    Examples:
            sb.plan_figure(&#34;fig-1&#34;,
                    [[&#34;graph-1&#34;],
                    [&#34;graph-2&#34;]],
                    {
                        &#34;height&#34;: 6,
                        &#34;width&#34;: 3,
                    },
                    out  = &#34;samplefig.svg&#34;
            )

            We See here this will create a 1 by 2 matrix where the first row will contain graph-1
            and the second will contain graph 2

            The figure will be modified to have a figure height of 6, and width of 3 and saved to
            sampelefig.svg
    &#34;&#34;&#34;
    if name in _sb_figures:
        error(&#34;Figure already defined: {}&#34;.format(name))

    _sb_figures[name] = Figure(name, graph_layout, formatter, out)</code></pre>
</details>
</dd>
<dt id="progbg.core.plan_graph"><code class="name flex">
<span>def <span class="ident">plan_graph</span></span>(<span>name: str, graphobj)</span>
</code></dt>
<dd>
<div class="desc"><p>Plan a graph object
Takes a graph object (LineGraph, etc) and ties the a name to it to be
used by figures</p>
<h2 id="argument">Argument</h2>
<p>name: Name of the graph object - must be unique among all graphs
graphobj: Graph object to tie to the name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plan_graph(name: str, graphobj):
    &#34;&#34;&#34;Plan a graph object
    Takes a graph object (LineGraph, etc) and ties the a name to it to be
    used by figures

    Argument:
        name: Name of the graph object - must be unique among all graphs
        graphobj: Graph object to tie to the name
    &#34;&#34;&#34;
    if name in _sb_graphs:
        error(&#34;Graph already defined: {}&#34;.format(name))

    _sb_graphs[name] = graphobj</code></pre>
</details>
</dd>
<dt id="progbg.core.plan_parse"><code class="name flex">
<span>def <span class="ident">plan_parse</span></span>(<span>file, parse_file_func, out_dir: str = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plan_parse(file, parse_file_func, out_dir: str = None):
    _sb_executions.append(ParseExecution(file, out_dir, parse_file_func))
    return _sb_executions[-1]</code></pre>
</details>
</dd>
<dt id="progbg.core.registerbackend"><code class="name flex">
<span>def <span class="ident">registerbackend</span></span>(<span>cls)</span>
</code></dt>
<dd>
<div class="desc"><p>Regististration of a backend class</p>
<p>Argument:
cls: Class definition to wrap and register</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def registerbackend(cls):
    &#34;&#34;&#34;Regististration of a backend class

    Argument:
    cls: Class definition to wrap and register
    &#34;&#34;&#34;
    if not hasattr(cls, &#34;start&#34;):
        error(&#34;Backend requires the init function: {}&#34;.format(cls.__name__))

    if not hasattr(cls, &#34;uninit&#34;):
        error(&#34;Backend requires the uninit function: {}&#34;.format(cls.__name__))

    _check_names(cls, cls.start)
    _check_names(cls, cls.uninit)

    def construct(self, consts={}, vars=[]):
        self.vars = Variables(consts, vars)
        self.name = cls.__name__

    spec = inspect.getfullargspec(cls.start)
    old = cls.start

    def wrapped_start(**kwargs):
        args = get_args(spec, **kwargs)
        return old(**args)

    cls.__init__ = construct
    cls.start = wrapped_start

    _sb_registered_backend[cls.__name__.lower()] = cls

    return cls</code></pre>
</details>
</dd>
<dt id="progbg.core.registerbackend_sh"><code class="name flex">
<span>def <span class="ident">registerbackend_sh</span></span>(<span>name: str, file_path: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def registerbackend_sh(name: str, file_path: str):
    custom_backend = type(name, (object, ), {})

    @staticmethod
    def init():
        shell = subprocess.Popen(
            &#34;sh&#34;, stdin=subprocess.PIPE, stdout=subprocess.PIPE)
        script = open(file_path, &#34;r&#34;).read()
        script += &#34;\n&#34;
        shell.stdin.write(str.encode(script))
        shell.stdin.write(str.encode(&#34;init &gt; /dev/null\n&#34;))
        shell.stdin.write(str.encode(&#34;env\n&#34;))
        shell.stdin.close()
        environment = dict()
        for line in shell.stdout:
            name, value = line.decode(&#39;ascii&#39;).strip().split(&#39;=&#39;, 1)
            environment[name] = value
        uniq = {k: environment[k] for k in set(environment) - set(os.environ)}
        custom_backend.env = uniq
        shell.wait()

    custom_backend.init = init

    @staticmethod
    def uninit():
        shell = subprocess.Popen(
            &#34;sh&#34;, stdin=subprocess.PIPE, stdout=subprocess.PIPE, env=custom_backend.env)
        script = open(file_path, &#34;r&#34;).read()
        script += &#34;\n&#34;
        shell.stdin.write(str.encode(script))
        shell.stdin.write(str.encode(&#34;uninit\n&#34;))
        shell.stdin.close()
        shell.wait()

    custom_backend.uninit = uninit

    registerbackend(custom_backend)</code></pre>
</details>
</dd>
<dt id="progbg.core.registerbenchmark"><code class="name flex">
<span>def <span class="ident">registerbenchmark</span></span>(<span>cls)</span>
</code></dt>
<dd>
<div class="desc"><p>Register for benchmark</p>
<p>cls: Class definition to wrap and register</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def registerbenchmark(cls):
    &#34;&#34;&#34;Register for benchmark

    cls: Class definition to wrap and register
    &#34;&#34;&#34;
    if not hasattr(cls, &#34;run&#34;):
        error(&#34;Benchmark requires the run function: {}&#34;.format(cls.__name__))

    if not _has_required_args(cls.run):
        error(&#34;Benchmark run needs 2 argument for output path: {}&#34;.format(cls.__name__))

    _check_names(cls, cls.run, is_run=True)

    def construct(self, consts={}, vars=[], iterations=1):
        self.variables = Variables(consts, vars)
        self.iterations = iterations
        self.name = cls.__name__

    cls.__init__ = construct

    _sb_registered_benchmarks[cls.__name__.lower()] = cls

    return cls</code></pre>
</details>
</dd>
<dt id="progbg.core.registerbenchmark_sh"><code class="name flex">
<span>def <span class="ident">registerbenchmark_sh</span></span>(<span>name: str, file_path: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def registerbenchmark_sh(name: str, file_path: str):
    custom_backend = type(name, (object, ), {})

    @staticmethod
    def run(backend, out_file):
        out = open(out_file, &#39;w&#39;)
        shell = subprocess.Popen(&#34;sh&#34;, stdin=subprocess.PIPE, stdout=out)
        script = open(file_path, &#34;r&#34;).read()
        script += &#34;\n&#34;
        shell.stdin.write(str.encode(script))
        script = open(file_path, &#34;r&#34;).read()
        run_str = &#34;run\n&#34;.format(i)
        shell.stdin.write(str.encode(run_str))
        shell.stdin.close()
        shell.wait()

    custom_backend.run = run
    registerbenchmark(custom_backend)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="progbg.core.Execution"><code class="flex name class">
<span>class <span class="ident">Execution</span></span>
<span>(</span><span>benchmark, backends: List, parser, out: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Execution class, see plan_execution documentation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Execution:
    &#34;&#34;&#34;Execution class, see plan_execution documentation&#34;&#34;&#34;

    def __init__(self, benchmark, backends: List, parser, out: str):
        self.bench = benchmark

        if backends:
            self.backends = backends
        else:
            self.backends = [NullBackend()]

        self.run_benchmarks = None
        self.out = out
        self.parser = parser
        self._cached = None
        self.name = &#34;,&#34;.join(
            [back.name for back in self.backends]) + &#34;-&#34; + self.bench.name

    def print(self, string):
        &#34;&#34;&#34;Pretty printer for execution&#34;&#34;&#34;
        print(&#34;\033[1;31m[{} - {}]:\033[0m {}&#34;.format(self.name,
                                                      self.bench.name, string))

    def tables(self):
        &#34;&#34;&#34;
        Generates the tables needed for the sqlite backend

        Table names are in the form EXECNAME__BENCHNAME__BACKENDS
        Composed backends are seperated by &#34;_b_&#34;.  This is because characters
        like &#34;/&#34; and &#34;-&#34; and &#34;:&#34; are not accepted by sqlite.
        &#34;&#34;&#34;
        tables = {}
        if self.backends:
            for back_obj in self.backends:
                fields_backends = _retrieve_named_backends(back_obj)
                fields_benchmark = _retrieve_named_benchmarks(self.bench.name)
                fields_parser = self.bench.parser.fields()
                tablename = &#34;{}__{}__{}&#34;.format(self.name,
                                                self.bench.name, back_obj.path_sql)
                fields = fields_backends + fields_benchmark + fields_parser + _sb_rnames
                tables[tablename] = sorted(fields)
        else:
            fields_benchmark = _retrieve_named_benchmarks(self.bench.name)
            fields_parser = self.bench.parser.fields()
            tablename = &#34;{}__{}&#34;.format(self.name,
                                        self.bench.name)
            fields = fields_benchmark + fields_parser + _sb_rnames
            tables[tablename] = sorted(fields)

        return tables

    def _setup_tables(self):
        conn = sqlite3.connect(self.out)
        for name, vals in self.tables.items():
            c = conn.cursor()
            quotes = [&#39;&#34;{}&#34;&#39;.format(val) for val in vals]
            exec_str = &#34;CREATE TABLE {} ({});&#34;.format(name, &#34;,&#34;.join(quotes))
            try:
                c.execute(exec_str)
            except sqlite3.OperationalError:
                exec_str = &#34;DELETE FROM {}&#34;.format(name)
                c.execute(exec_str)
            conn.commit()
            c.close()
        conn.close()

    # Constantly creating the connection is not so nice.
    def _add_sql_row(self, obj, bench_args, full_backend_args):
        conn = sqlite3.connect(self.out)
        c = conn.cursor()
        inserted = False
        for name_full, fields in self.tables.items():
            name = name_full.split(&#39;__&#39;)
            if obj[&#34;_execution_name&#34;] != name[0]:
                continue

            if obj[&#34;_workload&#34;] != name[1]:
                continue

            if len(name) == 3:
                sql_friendly = Backend.out_to_sql(obj[&#34;_backend&#34;])
                if sql_friendly != name[2]:
                    continue

                obj[&#34;_backend&#34;] = sql_friendly

            vals = []
            for val in fields:
                # We have to eliminate the first and last char as they are quotes
                if val in obj:
                    # If we do typing for object we would have to do it here?
                    # When we get the fields we would also ask for typing
                    # Its a feature that will probably need to be added sooner
                    # over later
                    vals.append(&#39;&#34;{}&#34;&#39;.format(str(obj[val])))
                else:
                    if full_backend_args and val in full_backend_args:
                        vals.append(&#39;&#34;{}&#34;&#39;.format(str(full_backend_args[val])))
                    elif val in bench_args:
                        vals.append(&#39;&#34;{}&#34;&#39;.format(str(bench_args[val])))
                    else:
                        vals.append(&#39;&#34;&#34;&#39;)

            quotes = [&#39;&#34;{}&#34;&#39;.format(val.strip()) for val in fields]
            exec_str = &#34;INSERT INTO {} ({})\nVALUES ({});&#34;.format(name_full,
                                                                  &#34;,&#34;.join(quotes), &#34;,&#34;.join(vals))

            c.execute(exec_str)
            conn.commit()
            c.close()
            inserted = True
            break

        conn.close()
        if not inserted:
            raise Exception(&#34;Object was not/could not be added to any table&#34;)

    def clean(self):
        &#34;&#34;&#34;Cleans output directories&#34;&#34;&#34;
        if self.is_sql_backed():
            self._setup_tables()
        else:
            try:
                os.mkdir(self.out)
            except Exception as e:
                if len(os.listdir(self.out)) &gt; 0:
                    self.print(e)
                    self.print(
                        &#34;Problem creating out directory {}, test data already there&#34;.format(self.out))
                    exit(0)

    def _merged_args(self, back_vars):
        benchmark = self.bench.variables.produce_args()
        backend = back_vars.produce_args()
        args = []
        for back in backend:
            arg = dict(
                benchmark=benchmark,
                backend=back
            )
            args.append(arg)

        return args

    def parse(self):
        # Pretty messy having to do this twice but need to retrieve proper data
        if self._cached:
            self.print(&#34;Using cached parsed output&#34;)
            return

        combined = []
        for back in self.backends:
            args = self._merged_args(back.variables)
            for arg_set in args:
                bench_args = arg_set[&#34;benchmark&#34;]
                back_args = arg_set[&#34;backend&#34;]
                for ba in bench_args:
                    metrics = Metrics()
                    for k, v in ba.items():
                        metrics.add_constant(k, v)
                    for k, v in back_args.items():
                        metrics.add_constant(k, v)
                    for iteration in range(0,  self.bench.iterations):
                        out_file = os.path.abspath(self.out_file(back,
                                                                 back_args, ba, iteration))
                        self.parser(metrics, out_file)
                    combined.append(metrics)

        self._cached = combined

    def out_file(self, back_obj, backend_args, bench_args, iteration):
        &#34;&#34;&#34;Determine output filename given a some backend and bench arguments

        output is {Execution_name}_b_{BCK1-BCK2}_{BCKVARS}_{WRKVARS}
        &#34;&#34;&#34;
        file = self.bench.__class__.__name__
        file += &#34;_b_{}&#34;.format(back_obj.name)
        for name in back_obj.variables.y_names():
            file += &#34;_{}&#34;.format(backend_args[name])

        for name in self.bench.variables.y_names():
            file += &#34;_{}&#34;.format(bench_args[name])
        file += &#34;_{}&#34;.format(iteration)

        if self.is_sql_backed():
            return &#34;{}&#34;.format(file)

        return &#34;{}/{}&#34;.format(self.out, file)

    def is_sql_backed(self):
        &#34;&#34;&#34;Checks if execution storage backend is sqlite3&#34;&#34;&#34;
        return self.out.endswith(&#39;.db&#39;)

    def execute(self):
        &#34;&#34;&#34;Execute the execution defined

        Argument:
            args: Arguments namespace from the cli
        &#34;&#34;&#34;
        # Go through every registered backend
        for back in self.backends:
            args = self._merged_args(back.variables)

            # Go through every argument possibility given consts
            # and variables
            for arg_set in args:
                bench_args = arg_set[&#34;benchmark&#34;]
                back_args = arg_set[&#34;backend&#34;]
                back.__class__.start(**back_args)
                # Go through every benchmark argument listing
                for ba in bench_args:
                    for iteration in range(0,  self.bench.iterations):
                        out_file = os.path.abspath(self.out_file(back,
                                                                 back_args, ba, iteration))
                        self.bench.__class__.run(back.name, out_file, **ba)
                back.__class__.uninit()

    def param_exists(self, name: str) -&gt; bool:
        &#34;&#34;&#34;Checks if a param exists within either the benchmark or the parser&#34;&#34;&#34;
        bench_has = self.bench.param_exists(name)
        if self.backends:
            backend_has = any([back_obj.runtime_variables.param_exists(name)
                               for back_obj in self.backends])
        else:
            backend_has = False

        return bench_has or backend_has

    def __str__(self):
        title = self.bench.name + &#34;(&#34;
        for back in self.backends:
            title += &#34;{}&#34;.format(back.name)
        title += &#34;)&#34;
        return &#34;{}&#34;.format(title)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="progbg.core.Execution.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Cleans output directories</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean(self):
    &#34;&#34;&#34;Cleans output directories&#34;&#34;&#34;
    if self.is_sql_backed():
        self._setup_tables()
    else:
        try:
            os.mkdir(self.out)
        except Exception as e:
            if len(os.listdir(self.out)) &gt; 0:
                self.print(e)
                self.print(
                    &#34;Problem creating out directory {}, test data already there&#34;.format(self.out))
                exit(0)</code></pre>
</details>
</dd>
<dt id="progbg.core.Execution.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Execute the execution defined</p>
<h2 id="argument">Argument</h2>
<p>args: Arguments namespace from the cli</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(self):
    &#34;&#34;&#34;Execute the execution defined

    Argument:
        args: Arguments namespace from the cli
    &#34;&#34;&#34;
    # Go through every registered backend
    for back in self.backends:
        args = self._merged_args(back.variables)

        # Go through every argument possibility given consts
        # and variables
        for arg_set in args:
            bench_args = arg_set[&#34;benchmark&#34;]
            back_args = arg_set[&#34;backend&#34;]
            back.__class__.start(**back_args)
            # Go through every benchmark argument listing
            for ba in bench_args:
                for iteration in range(0,  self.bench.iterations):
                    out_file = os.path.abspath(self.out_file(back,
                                                             back_args, ba, iteration))
                    self.bench.__class__.run(back.name, out_file, **ba)
            back.__class__.uninit()</code></pre>
</details>
</dd>
<dt id="progbg.core.Execution.is_sql_backed"><code class="name flex">
<span>def <span class="ident">is_sql_backed</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if execution storage backend is sqlite3</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_sql_backed(self):
    &#34;&#34;&#34;Checks if execution storage backend is sqlite3&#34;&#34;&#34;
    return self.out.endswith(&#39;.db&#39;)</code></pre>
</details>
</dd>
<dt id="progbg.core.Execution.out_file"><code class="name flex">
<span>def <span class="ident">out_file</span></span>(<span>self, back_obj, backend_args, bench_args, iteration)</span>
</code></dt>
<dd>
<div class="desc"><p>Determine output filename given a some backend and bench arguments</p>
<p>output is {Execution_name}<em BCK1-BCK2>b</em><em WRKVARS>{BCKVARS}</em></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def out_file(self, back_obj, backend_args, bench_args, iteration):
    &#34;&#34;&#34;Determine output filename given a some backend and bench arguments

    output is {Execution_name}_b_{BCK1-BCK2}_{BCKVARS}_{WRKVARS}
    &#34;&#34;&#34;
    file = self.bench.__class__.__name__
    file += &#34;_b_{}&#34;.format(back_obj.name)
    for name in back_obj.variables.y_names():
        file += &#34;_{}&#34;.format(backend_args[name])

    for name in self.bench.variables.y_names():
        file += &#34;_{}&#34;.format(bench_args[name])
    file += &#34;_{}&#34;.format(iteration)

    if self.is_sql_backed():
        return &#34;{}&#34;.format(file)

    return &#34;{}/{}&#34;.format(self.out, file)</code></pre>
</details>
</dd>
<dt id="progbg.core.Execution.param_exists"><code class="name flex">
<span>def <span class="ident">param_exists</span></span>(<span>self, name: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if a param exists within either the benchmark or the parser</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def param_exists(self, name: str) -&gt; bool:
    &#34;&#34;&#34;Checks if a param exists within either the benchmark or the parser&#34;&#34;&#34;
    bench_has = self.bench.param_exists(name)
    if self.backends:
        backend_has = any([back_obj.runtime_variables.param_exists(name)
                           for back_obj in self.backends])
    else:
        backend_has = False

    return bench_has or backend_has</code></pre>
</details>
</dd>
<dt id="progbg.core.Execution.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(self):
    # Pretty messy having to do this twice but need to retrieve proper data
    if self._cached:
        self.print(&#34;Using cached parsed output&#34;)
        return

    combined = []
    for back in self.backends:
        args = self._merged_args(back.variables)
        for arg_set in args:
            bench_args = arg_set[&#34;benchmark&#34;]
            back_args = arg_set[&#34;backend&#34;]
            for ba in bench_args:
                metrics = Metrics()
                for k, v in ba.items():
                    metrics.add_constant(k, v)
                for k, v in back_args.items():
                    metrics.add_constant(k, v)
                for iteration in range(0,  self.bench.iterations):
                    out_file = os.path.abspath(self.out_file(back,
                                                             back_args, ba, iteration))
                    self.parser(metrics, out_file)
                combined.append(metrics)

    self._cached = combined</code></pre>
</details>
</dd>
<dt id="progbg.core.Execution.print"><code class="name flex">
<span>def <span class="ident">print</span></span>(<span>self, string)</span>
</code></dt>
<dd>
<div class="desc"><p>Pretty printer for execution</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print(self, string):
    &#34;&#34;&#34;Pretty printer for execution&#34;&#34;&#34;
    print(&#34;\033[1;31m[{} - {}]:\033[0m {}&#34;.format(self.name,
                                                  self.bench.name, string))</code></pre>
</details>
</dd>
<dt id="progbg.core.Execution.tables"><code class="name flex">
<span>def <span class="ident">tables</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates the tables needed for the sqlite backend</p>
<p>Table names are in the form EXECNAME__BENCHNAME__BACKENDS
Composed backends are seperated by "<em>b</em>".
This is because characters
like "/" and "-" and ":" are not accepted by sqlite.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tables(self):
    &#34;&#34;&#34;
    Generates the tables needed for the sqlite backend

    Table names are in the form EXECNAME__BENCHNAME__BACKENDS
    Composed backends are seperated by &#34;_b_&#34;.  This is because characters
    like &#34;/&#34; and &#34;-&#34; and &#34;:&#34; are not accepted by sqlite.
    &#34;&#34;&#34;
    tables = {}
    if self.backends:
        for back_obj in self.backends:
            fields_backends = _retrieve_named_backends(back_obj)
            fields_benchmark = _retrieve_named_benchmarks(self.bench.name)
            fields_parser = self.bench.parser.fields()
            tablename = &#34;{}__{}__{}&#34;.format(self.name,
                                            self.bench.name, back_obj.path_sql)
            fields = fields_backends + fields_benchmark + fields_parser + _sb_rnames
            tables[tablename] = sorted(fields)
    else:
        fields_benchmark = _retrieve_named_benchmarks(self.bench.name)
        fields_parser = self.bench.parser.fields()
        tablename = &#34;{}__{}&#34;.format(self.name,
                                    self.bench.name)
        fields = fields_benchmark + fields_parser + _sb_rnames
        tables[tablename] = sorted(fields)

    return tables</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="progbg.core.Figure"><code class="flex name class">
<span>class <span class="ident">Figure</span></span>
<span>(</span><span>name: str, graphs: List[List[str]], formatter, out: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Create figure given a set of graphs, for more information see plan_figure documentation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Figure:
    &#34;&#34;&#34;Create figure given a set of graphs, for more information see plan_figure documentation&#34;&#34;&#34;

    def __init__(self,
                 name: str,
                 graphs: List[List[str]],
                 formatter,
                 out: str):
        check_formatter(formatter)

        self.name = name
        self.graphs = graphs
        self.formatter = formatter
        self.out = out

    def print(self, strn: str) -&gt; None:
        &#34;&#34;&#34;Pretty print function&#34;&#34;&#34;
        print(&#34;\033[1;35m[{}]:\033[0m {}&#34;.format(self.out, strn))

    def create(self):
        &#34;&#34;&#34;Create the figure&#34;&#34;&#34;
        self.print(&#34;Creating Figure&#34;)
        h = len(self.graphs)
        w = len(self.graphs[0])
        fig, axes = plt.subplots(ncols=w, nrows=h, squeeze=False)
        for y in range(0, h):
            for x in range(0, w):
                graph = _sb_graphs[self.graphs[y][x]]
                try:
                    graph.graph(axes[y][x], silent=True)
                except Exception as err:
                    error(&#34;Problem with graph {}: {}&#34;.format(self.name, err))

        format_fig(fig, axes, self.formatter)

        out = os.path.join(GRAPHS_DIR, self.out)
        plt.savefig(out, bbox_inches=&#34;tight&#34;, pad_inches=0)
        if not out.endswith(&#34;.svg&#34;):
            out = &#34;.&#34;.join(out.split(&#34;.&#34;)[:-1]) + &#34;.svg&#34;
            plt.savefig(out, bbox_inches=&#34;tight&#34;, pad_inches=0)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="progbg.core.Figure.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create the figure</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create(self):
    &#34;&#34;&#34;Create the figure&#34;&#34;&#34;
    self.print(&#34;Creating Figure&#34;)
    h = len(self.graphs)
    w = len(self.graphs[0])
    fig, axes = plt.subplots(ncols=w, nrows=h, squeeze=False)
    for y in range(0, h):
        for x in range(0, w):
            graph = _sb_graphs[self.graphs[y][x]]
            try:
                graph.graph(axes[y][x], silent=True)
            except Exception as err:
                error(&#34;Problem with graph {}: {}&#34;.format(self.name, err))

    format_fig(fig, axes, self.formatter)

    out = os.path.join(GRAPHS_DIR, self.out)
    plt.savefig(out, bbox_inches=&#34;tight&#34;, pad_inches=0)
    if not out.endswith(&#34;.svg&#34;):
        out = &#34;.&#34;.join(out.split(&#34;.&#34;)[:-1]) + &#34;.svg&#34;
        plt.savefig(out, bbox_inches=&#34;tight&#34;, pad_inches=0)</code></pre>
</details>
</dd>
<dt id="progbg.core.Figure.print"><code class="name flex">
<span>def <span class="ident">print</span></span>(<span>self, strn: str) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Pretty print function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print(self, strn: str) -&gt; None:
    &#34;&#34;&#34;Pretty print function&#34;&#34;&#34;
    print(&#34;\033[1;35m[{}]:\033[0m {}&#34;.format(self.out, strn))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="progbg.core.Metrics"><code class="flex name class">
<span>class <span class="ident">Metrics</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Metrics:
    def __init__(self):
        self._vars = dict()
        self._consts = dict()

    def add_metric(self, key, val):
        if key not in self._vars:
            self._vars[key] = [val]
        else:
            self._vars[key].append(val)

    def __getitem__(self, key):
        if key in self._vars:
            return self._vars[key]

        return self._consts[key]

    def add_constant(self, key, val):
        self._consts[key] = val

    def combinate(self, other: Dict):
        for key, val in other._vars.items():
            if key in self._vars:
                self._vars[key].append(val)
            else:
                self._vars[key] = val

    def get_stats(self):
        obj = dict()
        for key, val in self._vars.items():
            obj[key] = np.mean(val)
            obj[key + &#34;_std&#34;] = np.std(val)
        for key, val in self._consts.items():
            obj[key] = val

        return obj

    def __repr__(self):
        obj = self.get_stats()
        return pformat(obj)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="progbg.core.Metrics.add_constant"><code class="name flex">
<span>def <span class="ident">add_constant</span></span>(<span>self, key, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_constant(self, key, val):
    self._consts[key] = val</code></pre>
</details>
</dd>
<dt id="progbg.core.Metrics.add_metric"><code class="name flex">
<span>def <span class="ident">add_metric</span></span>(<span>self, key, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_metric(self, key, val):
    if key not in self._vars:
        self._vars[key] = [val]
    else:
        self._vars[key].append(val)</code></pre>
</details>
</dd>
<dt id="progbg.core.Metrics.combinate"><code class="name flex">
<span>def <span class="ident">combinate</span></span>(<span>self, other: Dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combinate(self, other: Dict):
    for key, val in other._vars.items():
        if key in self._vars:
            self._vars[key].append(val)
        else:
            self._vars[key] = val</code></pre>
</details>
</dd>
<dt id="progbg.core.Metrics.get_stats"><code class="name flex">
<span>def <span class="ident">get_stats</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_stats(self):
    obj = dict()
    for key, val in self._vars.items():
        obj[key] = np.mean(val)
        obj[key + &#34;_std&#34;] = np.std(val)
    for key, val in self._consts.items():
        obj[key] = val

    return obj</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="progbg.core.NoBenchmark"><code class="flex name class">
<span>class <span class="ident">NoBenchmark</span></span>
<span>(</span><span>parser)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NoBenchmark:
    def __init__(self, parser):
        self.parser = parser</code></pre>
</details>
</dd>
<dt id="progbg.core.NullBackend"><code class="flex name class">
<span>class <span class="ident">NullBackend</span></span>
<span>(</span><span>consts={}, var=[])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NullBackend:
    def __init__(self, consts={}, var=[]):
        self.var = Variables(consts, var)

    @staticmethod
    def init():
        pass

    @staticmethod
    def uninit():
        pass</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="progbg.core.NullBackend.init"><code class="name flex">
<span>def <span class="ident">init</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def init():
    pass</code></pre>
</details>
</dd>
<dt id="progbg.core.NullBackend.uninit"><code class="name flex">
<span>def <span class="ident">uninit</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def uninit():
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="progbg.core.ParseExecution"><code class="flex name class">
<span>class <span class="ident">ParseExecution</span></span>
<span>(</span><span>data: str, out_dir: str, func)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParseExecution:
    def __init__(self, data: str, out_dir: str, func):
        self._data = data
        self.out = out_dir
        self._func = func
        self.bench = NoBenchmark(self)
        self._cached = None

    def fields(self):
        return self._obj.keys()

    def is_sql_backed(self):
        return False

    def param_exists(self, param):
        return True

    def _parse_file(self, metrics, path: str, iter):
        self._func(metrics, path)

    def parse(self):
        if self._cached:
            return

        metrics = Metrics()
        if os.path.isdir(self._data):
            i = 0
            for file in os.listdir(self._data):
                path = os.path.join(self._data, file)
                self._parse_file(metrics, path, i)
                i += 1
        else:
            self._parse_file(metrics, self._data, 0)

        self._cached = [metrics]

    def execute(self):
        pass

    def clean(self):
        pass</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="progbg.core.ParseExecution.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean(self):
    pass</code></pre>
</details>
</dd>
<dt id="progbg.core.ParseExecution.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(self):
    pass</code></pre>
</details>
</dd>
<dt id="progbg.core.ParseExecution.fields"><code class="name flex">
<span>def <span class="ident">fields</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fields(self):
    return self._obj.keys()</code></pre>
</details>
</dd>
<dt id="progbg.core.ParseExecution.is_sql_backed"><code class="name flex">
<span>def <span class="ident">is_sql_backed</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_sql_backed(self):
    return False</code></pre>
</details>
</dd>
<dt id="progbg.core.ParseExecution.param_exists"><code class="name flex">
<span>def <span class="ident">param_exists</span></span>(<span>self, param)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def param_exists(self, param):
    return True</code></pre>
</details>
</dd>
<dt id="progbg.core.ParseExecution.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(self):
    if self._cached:
        return

    metrics = Metrics()
    if os.path.isdir(self._data):
        i = 0
        for file in os.listdir(self._data):
            path = os.path.join(self._data, file)
            self._parse_file(metrics, path, i)
            i += 1
    else:
        self._parse_file(metrics, self._data, 0)

    self._cached = [metrics]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="progbg" href="index.html">progbg</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="progbg.core.check_file_backend" href="#progbg.core.check_file_backend">check_file_backend</a></code></li>
<li><code><a title="progbg.core.compose_backends" href="#progbg.core.compose_backends">compose_backends</a></code></li>
<li><code><a title="progbg.core.execute_plan" href="#progbg.core.execute_plan">execute_plan</a></code></li>
<li><code><a title="progbg.core.get_args" href="#progbg.core.get_args">get_args</a></code></li>
<li><code><a title="progbg.core.import_plan" href="#progbg.core.import_plan">import_plan</a></code></li>
<li><code><a title="progbg.core.plan_execution" href="#progbg.core.plan_execution">plan_execution</a></code></li>
<li><code><a title="progbg.core.plan_figure" href="#progbg.core.plan_figure">plan_figure</a></code></li>
<li><code><a title="progbg.core.plan_graph" href="#progbg.core.plan_graph">plan_graph</a></code></li>
<li><code><a title="progbg.core.plan_parse" href="#progbg.core.plan_parse">plan_parse</a></code></li>
<li><code><a title="progbg.core.registerbackend" href="#progbg.core.registerbackend">registerbackend</a></code></li>
<li><code><a title="progbg.core.registerbackend_sh" href="#progbg.core.registerbackend_sh">registerbackend_sh</a></code></li>
<li><code><a title="progbg.core.registerbenchmark" href="#progbg.core.registerbenchmark">registerbenchmark</a></code></li>
<li><code><a title="progbg.core.registerbenchmark_sh" href="#progbg.core.registerbenchmark_sh">registerbenchmark_sh</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="progbg.core.Execution" href="#progbg.core.Execution">Execution</a></code></h4>
<ul class="two-column">
<li><code><a title="progbg.core.Execution.clean" href="#progbg.core.Execution.clean">clean</a></code></li>
<li><code><a title="progbg.core.Execution.execute" href="#progbg.core.Execution.execute">execute</a></code></li>
<li><code><a title="progbg.core.Execution.is_sql_backed" href="#progbg.core.Execution.is_sql_backed">is_sql_backed</a></code></li>
<li><code><a title="progbg.core.Execution.out_file" href="#progbg.core.Execution.out_file">out_file</a></code></li>
<li><code><a title="progbg.core.Execution.param_exists" href="#progbg.core.Execution.param_exists">param_exists</a></code></li>
<li><code><a title="progbg.core.Execution.parse" href="#progbg.core.Execution.parse">parse</a></code></li>
<li><code><a title="progbg.core.Execution.print" href="#progbg.core.Execution.print">print</a></code></li>
<li><code><a title="progbg.core.Execution.tables" href="#progbg.core.Execution.tables">tables</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="progbg.core.Figure" href="#progbg.core.Figure">Figure</a></code></h4>
<ul class="">
<li><code><a title="progbg.core.Figure.create" href="#progbg.core.Figure.create">create</a></code></li>
<li><code><a title="progbg.core.Figure.print" href="#progbg.core.Figure.print">print</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="progbg.core.Metrics" href="#progbg.core.Metrics">Metrics</a></code></h4>
<ul class="">
<li><code><a title="progbg.core.Metrics.add_constant" href="#progbg.core.Metrics.add_constant">add_constant</a></code></li>
<li><code><a title="progbg.core.Metrics.add_metric" href="#progbg.core.Metrics.add_metric">add_metric</a></code></li>
<li><code><a title="progbg.core.Metrics.combinate" href="#progbg.core.Metrics.combinate">combinate</a></code></li>
<li><code><a title="progbg.core.Metrics.get_stats" href="#progbg.core.Metrics.get_stats">get_stats</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="progbg.core.NoBenchmark" href="#progbg.core.NoBenchmark">NoBenchmark</a></code></h4>
</li>
<li>
<h4><code><a title="progbg.core.NullBackend" href="#progbg.core.NullBackend">NullBackend</a></code></h4>
<ul class="">
<li><code><a title="progbg.core.NullBackend.init" href="#progbg.core.NullBackend.init">init</a></code></li>
<li><code><a title="progbg.core.NullBackend.uninit" href="#progbg.core.NullBackend.uninit">uninit</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="progbg.core.ParseExecution" href="#progbg.core.ParseExecution">ParseExecution</a></code></h4>
<ul class="two-column">
<li><code><a title="progbg.core.ParseExecution.clean" href="#progbg.core.ParseExecution.clean">clean</a></code></li>
<li><code><a title="progbg.core.ParseExecution.execute" href="#progbg.core.ParseExecution.execute">execute</a></code></li>
<li><code><a title="progbg.core.ParseExecution.fields" href="#progbg.core.ParseExecution.fields">fields</a></code></li>
<li><code><a title="progbg.core.ParseExecution.is_sql_backed" href="#progbg.core.ParseExecution.is_sql_backed">is_sql_backed</a></code></li>
<li><code><a title="progbg.core.ParseExecution.param_exists" href="#progbg.core.ParseExecution.param_exists">param_exists</a></code></li>
<li><code><a title="progbg.core.ParseExecution.parse" href="#progbg.core.ParseExecution.parse">parse</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>